/*----- PROTECTED REGION ID(Calendar.cpp) ENABLED START -----*/
//=============================================================================
//
// file :        Calendar.cpp
//
// description : C++ source for the Calendar class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               Calendar are implemented in this file.
//
// project :     Calendar
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
//
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <Calendar.h>
#include <CalendarClass.h>

/*----- PROTECTED REGION END -----*/	//	Calendar.cpp

/**
 *  Calendar class description:
 *    Allow to define an activity for every hour.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name              |  Method name
//================================================================
//  State                     |  Inherited (no method)
//  Status                    |  Inherited (no method)
//  LoadActivities            |  load_activities
//  ExportActivities          |  export_activities
//  LoadShiftActivities       |  load_shift_activities
//  ExportShiftActivities     |  export_shift_activities
//  LoadRangeActivities       |  load_range_activities
//  LoadShiftRangeActivities  |  load_shift_range_activities
//  GetActivity               |  get_activity
//  GetShiftActivity          |  get_shift_activity
//  SearchActivity            |  search_activity
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//  activity          |  Tango::DevString	Scalar
//  shift             |  Tango::DevString	Scalar
//  time              |  Tango::DevString	Scalar
//  hour              |  Tango::DevUShort	Scalar
//  shiftActivity     |  Tango::DevString	Scalar
//  activityNum       |  Tango::DevShort	Scalar
//  shiftActivityNum  |  Tango::DevShort	Scalar
//  shiftNames        |  Tango::DevString	Spectrum  ( max = 24)
//  activities        |  Tango::DevString	Spectrum  ( max = 1000)
//================================================================

namespace Calendar_ns
{
/*----- PROTECTED REGION ID(Calendar::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	Calendar::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : Calendar::Calendar()
 *	Description : Constructors for a Tango device
 *                implementing the classCalendar
 */
//--------------------------------------------------------
Calendar::Calendar(Tango::DeviceClass *cl, string &s)
 : TANGO_BASE_CLASS(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(Calendar::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::constructor_1
}
//--------------------------------------------------------
Calendar::Calendar(Tango::DeviceClass *cl, const char *s)
 : TANGO_BASE_CLASS(cl, s)
{
	/*----- PROTECTED REGION ID(Calendar::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::constructor_2
}
//--------------------------------------------------------
Calendar::Calendar(Tango::DeviceClass *cl, const char *s, const char *d)
 : TANGO_BASE_CLASS(cl, s, d)
{
	/*----- PROTECTED REGION ID(Calendar::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : Calendar::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void Calendar::delete_device()
{
	DEBUG_STREAM << "Calendar::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(Calendar::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::delete_device
	delete[] attr_activity_read;
	delete[] attr_shift_read;
	delete[] attr_time_read;
	delete[] attr_hour_read;
	delete[] attr_shiftActivity_read;
	delete[] attr_activityNum_read;
	delete[] attr_shiftActivityNum_read;
	delete[] attr_shiftNames_read;
	delete[] attr_activities_read;
}

//--------------------------------------------------------
/**
 *	Method      : Calendar::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void Calendar::init_device()
{
	DEBUG_STREAM << "Calendar::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(Calendar::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	
	attr_activity_read = new Tango::DevString[1];
	attr_shift_read = new Tango::DevString[1];
	attr_time_read = new Tango::DevString[1];
	attr_hour_read = new Tango::DevUShort[1];
	attr_shiftActivity_read = new Tango::DevString[1];
	attr_activityNum_read = new Tango::DevShort[1];
	attr_shiftActivityNum_read = new Tango::DevShort[1];
	attr_shiftNames_read = new Tango::DevString[24];
	attr_activities_read = new Tango::DevString[1000];
	/*----- PROTECTED REGION ID(Calendar::init_device) ENABLED START -----*/
	
	//	Initialize device
	std::ifstream calFile(calendarFile, std::ofstream::in);

	for (std::string line; std::getline(calFile, line); )
	{
		try
		{
			load_line_conf(line, false/*already UTC*/);
		}
		catch(Tango::DevFailed &e)
		{
			set_state(Tango::FAULT);
			set_status(string(e.errors[0].desc));
		}
	}
	calFile.close();
	if(get_state() != Tango::FAULT)
	{
		set_state(Tango::ON);
		set_status("Calendar running");
	}

	memset(c_activities, 0, sizeof(c_activities));
	memset(c_shiftnames, 0, sizeof(c_shiftnames));
	size_t ind=0;
	for(vector<string>::iterator it=activities.begin(); it!=activities.end(); it++)
	{
		strcpy(c_activities[ind], it->c_str());
		attr_activities_read[ind] = c_activities[ind];
		ind++;
	}
	ind=0;
	for(vector<string>::iterator it=shiftNames.begin(); it!=shiftNames.end(); it++)
	{
		strcpy(c_shiftnames[ind], it->c_str());
		attr_shiftNames_read[ind] = c_shiftnames[ind];
		ind++;
	}

	/*----- PROTECTED REGION END -----*/	//	Calendar::init_device
}

//--------------------------------------------------------
/**
 *	Method      : Calendar::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void Calendar::get_device_property()
{
	/*----- PROTECTED REGION ID(Calendar::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("ShiftStartTimes"));
	dev_prop.push_back(Tango::DbDatum("ShiftNames"));
	dev_prop.push_back(Tango::DbDatum("CalendarFile"));
	dev_prop.push_back(Tango::DbDatum("Activities"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on CalendarClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		CalendarClass	*ds_class =
			(static_cast<CalendarClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize ShiftStartTimes from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  shiftStartTimes;
		else {
			//	Try to initialize ShiftStartTimes from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  shiftStartTimes;
		}
		//	And try to extract ShiftStartTimes value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  shiftStartTimes;

		//	Try to initialize ShiftNames from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  shiftNames;
		else {
			//	Try to initialize ShiftNames from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  shiftNames;
		}
		//	And try to extract ShiftNames value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  shiftNames;

		//	Try to initialize CalendarFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  calendarFile;
		else {
			//	Try to initialize CalendarFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  calendarFile;
		}
		//	And try to extract CalendarFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  calendarFile;

		//	Try to initialize Activities from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  activities;
		else {
			//	Try to initialize Activities from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  activities;
		}
		//	And try to extract Activities value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  activities;

	}

	/*----- PROTECTED REGION ID(Calendar::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : Calendar::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void Calendar::always_executed_hook()
{
	//DEBUG_STREAM << "Calendar::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(Calendar::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	time_t now= time(0);
	gmtime_r(&now,&now_utc_tm); //-> UTC
	localtime_r(&now,&now_local_tm);
	char buf[42];
	strftime(buf, sizeof(buf), "%Y-%m-%d %H", &now_utc_tm);
	DEBUG_STREAM << __func__ << ": now is " << buf << " UTC" << endl;
#if 0
	//std::string now_utc()
	{
	  std::time_t now= std::time(0);
	  std::tm* now_tm= std::gmtime(&now); //-> UTC
	  char buf[42];
	  std::strftime(buf, sizeof(buf), "%Y-%m-%d %H", now_tm);
	  DEBUG_STREAM << __func__ << ": now is " << buf << " UTC" << endl;
	  //return buf;
	}

	//std::string now_localtime()
	{
	  std::time_t now= std::time(0);
	  std::tm* now_tm= std::localtime(&now);//-> localtime
	  char buf[42];
	  std::strftime(buf, sizeof(buf), "%Y-%m-%d %H", now_tm);
	  DEBUG_STREAM << __func__ << ": now is " << buf << " localtime" << endl;
	  //return buf;
	}


	//string_to_localtime(...)
	{
		tm t2;
		time_t tn;
		/*//Seconds (0-60)
		t2.tm_sec = 0;
		//Minutes (0-59)
		t2.tm_min = 25;
		//Hours (0-23)
		t2.tm_hour = 11;
		//Day of the month (1-31)
		t2.tm_mday = 29;
		//Month (0-11)
		t2.tm_mon = 2;
		//Year - 1900
		t2.tm_year = 117;*/

        memset(&t2, 0, sizeof(struct tm));
        strptime("2017-03-29 11", "%Y-%m-%d %H", &t2);

		//0: consider time to convert never dst, time converted automatically adjusted with dst
		//-1: consider time to convert already ok with dst, so no adjustment applied by mktime
		t2.tm_isdst = -1;

		tn = std::mktime(&t2)/*-timezone*/;//with -timezone as if GMT
		DEBUG_STREAM << __func__<<": --> tn="<<tn<<" timezone="<<timezone<<" isdst="<<t2.tm_isdst<<endl;
		struct tm * tmp;
		tmp = std::localtime(&tn);
		char buf[42];
		std::strftime(buf, sizeof(buf), "%Y-%m-%d %H", tmp);
		DEBUG_STREAM << __func__ << ": now is " << buf << " localtime" << endl;
	}
#endif
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : Calendar::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void Calendar::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	//DEBUG_STREAM << "Calendar::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(Calendar::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::read_attr_hardware
}

//--------------------------------------------------------
/**
 *	Read attribute activity related method
 *	Description: Actual activity
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Calendar::read_activity(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "Calendar::read_activity(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Calendar::read_activity) ENABLED START -----*/
	char utc_time_string[255];
	strftime(utc_time_string, sizeof(utc_time_string), "%Y-%m-%d %H", &now_utc_tm);
	DEBUG_STREAM << __func__<<": isdst="<<now_utc_tm.tm_isdst<<" utc time: " << utc_time_string<<endl;
	map<string,string>::iterator it = calendar.find(utc_time_string);
	if(it != calendar.end())
		strcpy(c_activity, it->second.c_str());
	else
		strcpy(c_activity, UNKNOWN_ACTIVITY);
	*attr_activity_read = c_activity;
	//	Set the attribute value
	attr.set_value(attr_activity_read);
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::read_activity
}
//--------------------------------------------------------
/**
 *	Read attribute shift related method
 *	Description: Actual shift
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Calendar::read_shift(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "Calendar::read_shift(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Calendar::read_shift) ENABLED START -----*/
	int hour = now_local_tm.tm_hour;
	bool end=false;
	size_t index = 0;

	if(shiftStartTimes.size() == 0)
		strcpy(c_shiftname,"Shift_00:00");
	while(index < shiftStartTimes.size())
	{
		size_t index2 = (index+1) % shiftStartTimes.size();
		//DEBUG_STREAM << " index="<<index<<" index2="<<index2<<" hour="<<hour<<" h1="<<shiftStartTimes[index]<<" h2="<<shiftStartTimes[index2]<<endl;
		if((shiftStartTimes[index] < shiftStartTimes[index2] &&
				(hour >= shiftStartTimes[index] && hour < shiftStartTimes[index2])) ||
			(shiftStartTimes[index] > shiftStartTimes[index2] &&
								(hour >= shiftStartTimes[index] || hour < shiftStartTimes[index2])))
		{
			if(index < shiftNames.size())
				strcpy(c_shiftname,shiftNames[index].c_str());
			else
				sprintf(c_shiftname, "Shift_%d:00", shiftStartTimes[index]);
			//DEBUG_STREAM << " FOUND index="<<index<<" -> shiftname="<<shiftname<<endl;
			break;
		}
		index++;
	}
	*attr_shift_read = c_shiftname;
	//	Set the attribute value
	attr.set_value(attr_shift_read);
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::read_shift
}
//--------------------------------------------------------
/**
 *	Read attribute time related method
 *	Description: Actual time as YYYY-MM-DD HH
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Calendar::read_time(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "Calendar::read_time(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Calendar::read_time) ENABLED START -----*/
	/*std::time_t t = timegm(now_utc);

	std::tm * tmp;
	tmp = std::localtime(&t);*/
	strftime(c_local_time_string, sizeof(c_local_time_string), "%Y-%m-%d %H", &now_local_tm);
	DEBUG_STREAM << __func__<<": isdst="<<now_local_tm.tm_isdst<<" local time: " << c_local_time_string<<endl;

	*attr_time_read = c_local_time_string;
	//	Set the attribute value
	attr.set_value(attr_time_read);
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::read_time
}
//--------------------------------------------------------
/**
 *	Read attribute hour related method
 *	Description: Actual hour
 *
 *	Data type:	Tango::DevUShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Calendar::read_hour(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "Calendar::read_hour(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Calendar::read_hour) ENABLED START -----*/
	/*std::time_t t = timegm(now_utc);
	std::tm * tmp;
	tmp = std::localtime(&t);*/

	DEBUG_STREAM << __func__<<": isdst="<<now_local_tm.tm_isdst<<" local hour: " << now_local_tm.tm_hour<<endl;
	*attr_hour_read = now_local_tm.tm_hour;
	//	Set the attribute value
	attr.set_value(attr_hour_read);
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::read_hour
}
//--------------------------------------------------------
/**
 *	Read attribute shiftActivity related method
 *	Description: Actual activity of this shift
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Calendar::read_shiftActivity(Tango::Attribute &attr)
{
	DEBUG_STREAM << "Calendar::read_shiftActivity(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Calendar::read_shiftActivity) ENABLED START -----*/
	//find in which shift we are
#if 0
	int hour = now_local_tm.tm_hour;

	size_t index = 0;
	map<string, int> map_shift_activities_count;
	int max_count = 0;
	vector<string> v_string_shift_utc_hours;

	if(shiftStartTimes.size() == 0)
		strcpy(c_shiftname,"Shift_00:00");
	size_t index2;
	while(index < shiftStartTimes.size())
	{
		index2 = (index+1) % shiftStartTimes.size();
		//DEBUG_STREAM << " index="<<index<<" index2="<<index2<<" hour="<<hour<<" h1="<<shiftStartTimes[index]<<" h2="<<shiftStartTimes[index2]<<endl;
		if((shiftStartTimes[index] < shiftStartTimes[index2] &&
				(hour >= shiftStartTimes[index] && hour < shiftStartTimes[index2])) ||
			(shiftStartTimes[index] > shiftStartTimes[index2] &&
								(hour >= shiftStartTimes[index] || hour < shiftStartTimes[index2])))
		{
			if(index < shiftNames.size())
				strcpy(c_shiftname,shiftNames[index].c_str());
			else
				sprintf(c_shiftname, "Shift_%d:00", shiftStartTimes[index]);
			DEBUG_STREAM << __func__<<": FOUND index="<<index<<" -> shiftname="<<c_shiftname<<" start hour="<<shiftStartTimes[index] << " end hour="<<shiftStartTimes[index2]<<endl;
			break;
		}
		index++;
	}

	hour = shiftStartTimes[index];
	int diff_start_shift_hours = (now_local_tm.tm_hour + 24 - hour) % 24;
	DEBUG_STREAM << __func__<<" diff_start_shift_hours="<<diff_start_shift_hours<<endl;
	while((shiftStartTimes[index] < shiftStartTimes[index2] &&
			(hour >= shiftStartTimes[index] && hour < shiftStartTimes[index2])) ||
		(shiftStartTimes[index] > shiftStartTimes[index2] &&
							(hour >= shiftStartTimes[index] || hour < shiftStartTimes[index2])))
	{

		//get now utc but without minutes and seconds
		tm now_hour_utc_tm;
		time_t now= time(0);
		gmtime_r(&now, &now_hour_utc_tm); //-> UTC
		/*//Year - 1900
		now_hour_utc_tm.tm_year = now_utc_tm->tm_year;
		//Month (0-11)
		now_hour_utc_tm.tm_mon = now_utc_tm->tm_mon;
		//Day of the month (1-31)
		now_hour_utc_tm.tm_mday = now_utc_tm->tm_mday;
		//Hours (0-23)
		now_hour_utc_tm.tm_hour = now_utc_tm->tm_hour;*/
		//Minutes (0-59)
		now_hour_utc_tm.tm_min = 0;
		//Seconds (0-60)
		now_hour_utc_tm.tm_sec = 0;

		//subtract difference in hours since start shift
		time_t now_hour_utc_t = timegm(&now_hour_utc_tm);
		now_hour_utc_t = now_hour_utc_t - diff_start_shift_hours*3600+((hour-shiftStartTimes[index]+24)%24)*3600;

		//convert to utc string time (used as calendar map key)
		tm shift_utc_tm;
		gmtime_r(&now_hour_utc_t, &shift_utc_tm);
		char string_shift_hour[255];
		strftime(string_shift_hour, sizeof(string_shift_hour), "%Y-%m-%d %H", &shift_utc_tm);
		DEBUG_STREAM << __func__<<" looping hour="<<hour<<" -> " << string_shift_hour << endl;

		//save list of shift utc hours
		v_string_shift_utc_hours.push_back(string_shift_hour);

		//look for the corresponding activity
		map<string,string>::iterator itcal = calendar.find(string_shift_hour);
		if(itcal != calendar.end())
		{
			map<string,int>::iterator itmap = map_shift_activities_count.find(itcal->second);
			if(itmap == map_shift_activities_count.end()) //new activity
			{
				map_shift_activities_count.insert(make_pair(itcal->second, 1));
				if(max_count < 1)
					max_count = 1;
				DEBUG_STREAM << __func__<<" hour="<<hour<<" found new activity=" << itcal->second << " max_count=" << max_count << endl;
			}
			else	//already inserted -> increase counter
			{
				itmap->second = itmap->second + 1;
				if(max_count < itmap->second)
					max_count = itmap->second;
				DEBUG_STREAM << __func__<<" hour="<<hour<<" found existing activity=" << itcal->second << " counter=" << itmap->second << " max_count=" << max_count << endl;
			}
		}
		hour = (hour + 1) % 24;
	}

	//look if more than one activity with the same max counter
	vector<string> activity_modes;
	for(map<string,int>::iterator itmap = map_shift_activities_count.begin(); itmap != map_shift_activities_count.end(); itmap++)
	{
		if(itmap->second == max_count)
		{
			activity_modes.push_back(itmap->first);
			DEBUG_STREAM << __func__<<" found MAX count(" << max_count << ") activity=" << itmap->first << endl;
		}
	}
	if(activity_modes.size() == 1)
	{
		strcpy(c_shiftactivity, (activity_modes.begin())->c_str());
		DEBUG_STREAM << __func__<<" only one max count activity=" << c_shiftactivity << endl;
	}
	else if(activity_modes.size() > 1)
	{
		DEBUG_STREAM << __func__<<" there are " << activity_modes.size() << " max count activities" << endl;
		//loop from the last hour of the shift
		for (size_t ind = v_string_shift_utc_hours.size(); ind-- > 0; )
		{
			DEBUG_STREAM << __func__<<" - looking for the activity in shift hour=" << v_string_shift_utc_hours[ind] << " max count activities, ind="<<ind << endl;
			//look for the corresponding activity
			map<string,string>::iterator itcal = calendar.find(v_string_shift_utc_hours[ind]);
			if(itcal != calendar.end())
			{
				DEBUG_STREAM << __func__<<" -- found an activity=" << itcal->second << " for shift hour=" << v_string_shift_utc_hours[ind] << endl;
				//loop all max counter activities checking if it is the one of this hour
				for(vector<string>::iterator itmodes=activity_modes.begin(); itmodes != activity_modes.end(); itmodes++)
				{
					DEBUG_STREAM << __func__<<" --- looping max count activities =" << *itmodes  << endl;
					if(*itmodes == itcal->second)
					{
						strcpy(c_shiftactivity, itmodes->c_str());
						DEBUG_STREAM << __func__<<" --- FOUND more recent max count activity =" << c_shiftactivity  << endl;
						ind = 0;//exit also outer loop
						break;
					}
				}
			}
		}
	}
	else
	{
		strcpy(c_shiftactivity, UNKNOWN_ACTIVITY);
		DEBUG_STREAM << __func__<<" --- NO activity during shift -> " << c_shiftactivity  << endl;
	}
#else
	string shift_activity;
	string shiftname;
	get_shift_activity(now_local_tm, shift_activity, shiftname);
	strcpy(c_shiftactivity, shift_activity.c_str());
#endif

	*attr_shiftActivity_read = c_shiftactivity;
	//	Set the attribute value
	attr.set_value(attr_shiftActivity_read);
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::read_shiftActivity
}
//--------------------------------------------------------
/**
 *	Read attribute activityNum related method
 *	Description: Number corresponding to activity label, -1 if unknown activity
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Calendar::read_activityNum(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "Calendar::read_activityNum(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Calendar::read_activityNum) ENABLED START -----*/
	char utc_time_string[255];
	strftime(utc_time_string, sizeof(utc_time_string), "%Y-%m-%d %H", &now_utc_tm);
	DEBUG_STREAM << __func__<<": isdst="<<now_utc_tm.tm_isdst<<" utc time: " << utc_time_string<<endl;
	map<string,string>::iterator it = calendar.find(utc_time_string);
	if(it != calendar.end())
	{
		vector<string>::iterator itact = find(activities.begin(), activities.end(), it->second);
		if(itact != activities.end())
		{
			cout << __func__ << ": FOUND activity " << it->second << endl;
			*attr_activityNum_read  = itact - activities.begin();
			cout << __func__ << ": FOUND activityNum " << *attr_activityNum_read << endl;
		}
	}
	else
	{
		cout << __func__ << ": NOT FOUND activity"<< endl;
		*attr_activityNum_read = UNKNOWN_ACTIVITY_NUM;
	}
	cout << __func__ << ": attr_activityNum_read="<<*attr_activityNum_read<< endl;
	//	Set the attribute value
	attr.set_value(attr_activityNum_read);
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::read_activityNum
}
//--------------------------------------------------------
/**
 *	Read attribute shiftActivityNum related method
 *	Description: Number corresponding to activity label, -1 if unknown activity
 *
 *	Data type:	Tango::DevShort
 *	Attr type:	Scalar
 */
//--------------------------------------------------------
void Calendar::read_shiftActivityNum(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "Calendar::read_shiftActivityNum(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Calendar::read_shiftActivityNum) ENABLED START -----*/
	string shift_activity;
	string shiftname;
	get_shift_activity(now_local_tm, shift_activity, shiftname);

	vector<string>::iterator itact = find(activities.begin(), activities.end(), shift_activity);
	if(itact != activities.end())
		*attr_shiftActivityNum_read  = itact - activities.begin();
	else
		*attr_activityNum_read = UNKNOWN_ACTIVITY_NUM;
	//	Set the attribute value
	attr.set_value(attr_shiftActivityNum_read);
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::read_shiftActivityNum
}
//--------------------------------------------------------
/**
 *	Read attribute shiftNames related method
 *	Description: Array of shift names
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 24
 */
//--------------------------------------------------------
void Calendar::read_shiftNames(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "Calendar::read_shiftNames(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Calendar::read_shiftNames) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_shiftNames_read, shiftNames.size());
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::read_shiftNames
}
//--------------------------------------------------------
/**
 *	Read attribute activities related method
 *	Description: Array of possible activities
 *
 *	Data type:	Tango::DevString
 *	Attr type:	Spectrum max = 1000
 */
//--------------------------------------------------------
void Calendar::read_activities(Tango::Attribute &attr)
{
	//DEBUG_STREAM << "Calendar::read_activities(Tango::Attribute &attr) entering... " << endl;
	/*----- PROTECTED REGION ID(Calendar::read_activities) ENABLED START -----*/
	//	Set the attribute value
	attr.set_value(attr_activities_read, activities.size());
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::read_activities
}

//--------------------------------------------------------
/**
 *	Method      : Calendar::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void Calendar::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(Calendar::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command LoadActivities related method
 *	Description: Load an array of:
 *               time=YYYY-MM-DD HH;activity=..
 *
 *	@param argin Array of:
 *               time=YYYY-MM-DD HH;activity=..
 */
//--------------------------------------------------------
void Calendar::load_activities(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "Calendar::LoadActivities()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Calendar::load_activities) ENABLED START -----*/
	
	//	Add your own code
	size_t len = argin->length();
	for(size_t ind=0; ind < len; ind++)
	{
		string arg((*argin)[ind]);
		load_line_conf(arg, true/*convert from local time to UTC*/);
	}
	std::ofstream calFile(calendarFile, std::ofstream::out);
	for(map<string,string>::iterator it=calendar.begin(); it!= calendar.end(); it++)
	{
		calFile << KEY_TIME << "=" << it->first << ";" << KEY_ACTIVITY << "=" << it->second << endl;
	}
	calFile.close();
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::load_activities
}
//--------------------------------------------------------
/**
 *	Command ExportActivities related method
 *	Description: Export an array of:
 *               time=YYYY-MM-DD HH;activity=..
 *
 *	@returns Array of:
 *           time=YYYY-MM-DD HH;activity=..
 */
//--------------------------------------------------------
Tango::DevVarStringArray *Calendar::export_activities()
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "Calendar::ExportActivities()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Calendar::export_activities) ENABLED START -----*/
	
	//	Add your own code
	argout  = new Tango::DevVarStringArray();
	argout->length(calendar.size());
	size_t ind=0;
	for(map<string,string>::iterator it=calendar.begin(); it!= calendar.end(); it++)
	{
		string str_time_ok;
		tm tm_tmp;
		char *ret;
		memset(&tm_tmp, 0, sizeof(struct tm));
		ret = strptime(it->first.c_str(), "%Y-%m-%d %H", &tm_tmp);

		tm_tmp.tm_isdst = -1;	//user inputs time as localtime already with DST applied
		time_t tt1 = timegm(&tm_tmp);	//convert utc tm_tmp to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
		tm tm_tmpconv1;
		localtime_r(&tt1, &tm_tmpconv1);	//convert calendar time to localtime tm
		char buf1[255];
		strftime(buf1, sizeof(buf1), "%Y-%m-%d %H", &tm_tmpconv1);
		str_time_ok = string(buf1);
		DEBUG_STREAM << __func__ << ": Converted from UTC '" << it->first << "' to LOCAL TIME '" << str_time_ok << "'" << endl;

		ostringstream line_conf;
		line_conf << KEY_TIME << "=" << str_time_ok << ";" << KEY_ACTIVITY << "=" << it->second;// << endl;
		(*argout)[ind++] = Tango::string_dup(line_conf.str().c_str());
	}
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::export_activities
	return argout;
}
//--------------------------------------------------------
/**
 *	Command LoadShiftActivities related method
 *	Description: Load an array of:
 *               time=YYYY-MM-DD shiftname;activity=..
 *
 *	@param argin Array of:
 *               time=YYYY-MM-DD shiftname;activity=..
 */
//--------------------------------------------------------
void Calendar::load_shift_activities(const Tango::DevVarStringArray *argin)
{
	DEBUG_STREAM << "Calendar::LoadShiftActivities()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Calendar::load_shift_activities) ENABLED START -----*/
	
	//	Add your own code
	
	size_t len = argin->length();
	for(size_t ind=0; ind < len; ind++)
	{
		string arg((*argin)[ind]);
		load_shift_conf(arg);
	}
	std::ofstream calFile(calendarFile, std::ofstream::out);
	for(map<string,string>::iterator it=calendar.begin(); it!= calendar.end(); it++)
	{
		calFile << KEY_TIME << "=" << it->first << ";" << KEY_ACTIVITY << "=" << it->second << endl;
	}
	calFile.close();

	/*----- PROTECTED REGION END -----*/	//	Calendar::load_shift_activities
}
//--------------------------------------------------------
/**
 *	Command ExportShiftActivities related method
 *	Description: Export an array of:
 *               time=YYYY-MM-DD shiftname;activity=..
 *
 *	@returns Array of:
 *           time=YYYY-MM-DD shiftname;activity=..
 */
//--------------------------------------------------------
Tango::DevVarStringArray *Calendar::export_shift_activities()
{
	Tango::DevVarStringArray *argout;
	DEBUG_STREAM << "Calendar::ExportShiftActivities()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Calendar::export_shift_activities) ENABLED START -----*/
	
	//	Add your own code
	argout  = new Tango::DevVarStringArray();

	vector<string> conf_shift;
	string old_time_shift_str;

	for(map<string,string>::iterator it=calendar.begin(); it!= calendar.end(); it++)
	{
		string str_time_ok;
		string str_time_shift;
		tm tm_tmp;
		char *ret;
		memset(&tm_tmp, 0, sizeof(struct tm));
		ret = strptime(it->first.c_str(), "%Y-%m-%d %H", &tm_tmp);

		tm_tmp.tm_isdst = -1;	//user inputs time as localtime already with DST applied
		time_t tt1 = timegm(&tm_tmp);	//convert utc tm_tmp to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
		tm tm_tmpconv1;
		localtime_r(&tt1, &tm_tmpconv1);	//convert calendar time to localtime tm
		/*char buf1[255];
		strftime(buf1, sizeof(buf1), "%Y-%m-%d", &tm_tmpconv1);
		str_time_ok = string(buf1);
		DEBUG_STREAM << __func__ << ": Converted from UTC '" << it->first << "' to LOCAL TIME '" << str_time_ok << "'" << endl;*/

		string shift_activity;
		string shiftname;
		get_shift_activity(tm_tmpconv1, shift_activity, str_time_shift);
		if(str_time_shift != old_time_shift_str)
		{
			ostringstream line_conf;
			line_conf << KEY_TIME << "=" << str_time_shift << ";" << KEY_ACTIVITY << "=" << shift_activity;// << endl;
			old_time_shift_str = str_time_shift;
			conf_shift.push_back(line_conf.str());
		}
	}
	argout->length(conf_shift.size());
	for(size_t ind=0; ind < conf_shift.size(); ind++)
	{
		(*argout)[ind] = Tango::string_dup(conf_shift[ind].c_str());
	}
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::export_shift_activities
	return argout;
}
//--------------------------------------------------------
/**
 *	Command LoadRangeActivities related method
 *	Description: Load an activity for the range begin time, end time:
 *               begin_time=YYYY-MM-DD HH;end_time=YYYY-MM-DD HH;activity=..
 *
 *	@param argin Begin time, end time, activity:
 *               begin_time=YYYY-MM-DD HH;end_time=YYYY-MM-DD HH;activity=..
 */
//--------------------------------------------------------
void Calendar::load_range_activities(Tango::DevString argin)
{
	DEBUG_STREAM << "Calendar::LoadRangeActivities()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Calendar::load_range_activities) ENABLED START -----*/
	//	Add your own code
	string arg(argin);
	DEBUG_STREAM <<__func__<< ": request '" << arg << "'" << endl;
	map<string,string> activity_conf;
	vector<string> v_activity_conf;
	string_explode(arg, ";", v_activity_conf);
	string_vector2map(v_activity_conf,"=",activity_conf);
	string str_time_begin;
	string str_time_end;
	string str_activity;
	try
	{
		str_time_begin = activity_conf.at(KEY_BEGIN_TIME);
	}
	catch(const std::out_of_range& e)
	{
		stringstream tmp;
		tmp << "Configuration parsing error looking for key '"<<KEY_BEGIN_TIME<<"='";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	try
	{
		str_time_end = activity_conf.at(KEY_END_TIME);
	}
	catch(const std::out_of_range& e)
	{
		stringstream tmp;
		tmp << "Configuration parsing error looking for key '"<<KEY_END_TIME<<"='";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	try
	{
		str_activity = activity_conf.at(KEY_ACTIVITY);
	}
	catch(const std::out_of_range& e)
	{
		stringstream tmp;
		tmp << "Configuration parsing error looking for key '"<<KEY_ACTIVITY<<"='";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}


	tm tm_tmp_begin;
	time_t tt_begin;
	char *ret;
	memset(&tm_tmp_begin, 0, sizeof(struct tm));
	ret = strptime(str_time_begin.c_str(), "%Y-%m-%d %H", &tm_tmp_begin);
	if(!ret)
	{
		stringstream tmp;
		tmp << "Error parsing time string '"<<str_time_begin<<"', it has to be YYYY-MM-DD HH";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	else
	{
		tm_tmp_begin.tm_isdst = -1;	//user inputs time as localtime already with DST applied
		//time_t tt_begin = timelocal(&tm_tmp);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
		tt_begin = mktime(&tm_tmp_begin);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
	}
	tm tm_tmp_end;
	time_t tt_end;
	memset(&tm_tmp_end, 0, sizeof(struct tm));
	ret = strptime(str_time_end.c_str(), "%Y-%m-%d %H", &tm_tmp_end);
	if(!ret)
	{
		stringstream tmp;
		tmp << "Error parsing time string '"<<str_time_end<<"', it has to be YYYY-MM-DD HH";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	else
	{
		tm_tmp_end.tm_isdst = -1;	//user inputs time as localtime already with DST applied
		//time_t tt_end = timelocal(&tm_tmp);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
		tt_end = mktime(&tm_tmp_end);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
	}

	if(tt_end < tt_begin)
	{
		stringstream tmp;
		tmp << "Begin time '" << str_time_begin << "' has to precede end time '"<<str_time_end<<"'";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}

	time_t tt_loop = tt_begin;
	while(tt_loop <= tt_end)
	{
		string str_time_ok;
		tm tm_tmpconv;
		gmtime_r(&tt_loop, &tm_tmpconv);	//convert calendar time to UTC tm
		char buf[255];
		strftime(buf, sizeof(buf), "%Y-%m-%d %H", &tm_tmpconv);
		str_time_ok = string(buf);
		ostringstream tmp;
		tmp << KEY_TIME << "=" << str_time_ok << ";" << KEY_ACTIVITY << "=" << str_activity;
		DEBUG_STREAM << __func__ << ": loading '" << tmp.str() << "'" << endl;
		load_line_conf(tmp.str(), false/*time already UTC*/);
		tt_loop += 3600; //increase by one hour
	}

	std::ofstream calFile(calendarFile, std::ofstream::out);
	for(map<string,string>::iterator it=calendar.begin(); it!= calendar.end(); it++)
	{
		calFile << KEY_TIME << "=" << it->first << ";" << KEY_ACTIVITY << "=" << it->second << endl;
	}
	calFile.close();
	/*----- PROTECTED REGION END -----*/	//	Calendar::load_range_activities
}
//--------------------------------------------------------
/**
 *	Command LoadShiftRangeActivities related method
 *	Description: Load an activity for the range begin shift, end shift:
 *               begin_time=YYYY-MM-DD shiftname;end_time=YYYY-MM-DD shiftname;activity=..
 *
 *	@param argin Begin shift, end shift, activity:
 *               begin_time=YYYY-MM-DD shiftname;end_time=YYYY-MM-DD shiftname;activity=..
 */
//--------------------------------------------------------
void Calendar::load_shift_range_activities(Tango::DevString argin)
{
	DEBUG_STREAM << "Calendar::LoadShiftRangeActivities()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Calendar::load_shift_range_activities) ENABLED START -----*/
	
	//	Add your own code
	string arg(argin);
	map<string,string> activity_conf;
	vector<string> v_activity_conf;
	string_explode(arg, ";", v_activity_conf);
	string_vector2map(v_activity_conf,"=",activity_conf);
	string str_time_begin;
	string str_time_end;
	string str_activity;
	try
	{
		str_time_begin = activity_conf.at(KEY_BEGIN_TIME);
	}
	catch(const std::out_of_range& e)
	{
		stringstream tmp;
		tmp << "Configuration parsing error looking for key '"<<KEY_BEGIN_TIME<<"='";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	try
	{
		str_time_end = activity_conf.at(KEY_END_TIME);
	}
	catch(const std::out_of_range& e)
	{
		stringstream tmp;
		tmp << "Configuration parsing error looking for key '"<<KEY_END_TIME<<"='";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	try
	{
		str_activity = activity_conf.at(KEY_ACTIVITY);
	}
	catch(const std::out_of_range& e)
	{
		stringstream tmp;
		tmp << "Configuration parsing error looking for key '"<<KEY_ACTIVITY<<"='";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}


	tm tm_tmp_begin;
	time_t tt_begin;
	char *ret;
	memset(&tm_tmp_begin, 0, sizeof(struct tm));
	ret = strptime(str_time_begin.c_str(), "%Y-%m-%d ", &tm_tmp_begin);
	if(!ret)
	{
		stringstream tmp;
		tmp << "Error parsing time string '"<<str_time_begin<<"', it has to be YYYY-MM-DD shiftname";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	else
	{
		string shiftname(ret);
		vector<string>::iterator it = find(shiftNames.begin(), shiftNames.end(),shiftname);
		if(it == shiftNames.end())
		{
			stringstream tmp;
			tmp << "Error '"<<shiftname<<"' is not an allowed shift name in (";
			for(vector<string>::iterator itlog=shiftNames.begin(); itlog != shiftNames.end(); itlog++)
			{
				tmp<<*itlog;
				if(itlog != shiftNames.end()-1)
					tmp << ",";
			}
			tmp << ")";

			INFO_STREAM << __func__<< ": " << tmp.str() << endl;
			Tango::Except::throw_exception( \
					(const char*)"PARSING_ERROR", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
		}
		size_t index = it - shiftNames.begin();
		if(index >= shiftNames.size())
		{
			stringstream tmp;
			tmp << "Error not found starting hour for shift '"<<shiftname<<"'";
			INFO_STREAM << __func__<< ": " << tmp.str() << endl;
			Tango::Except::throw_exception( \
					(const char*)"PARSING_ERROR", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
		}
		int begin_shift_hour = shiftStartTimes[index];
		tm_tmp_begin.tm_hour = begin_shift_hour;
		tm_tmp_begin.tm_isdst = -1;	//user inputs time as localtime already with DST applied
		//time_t tt_begin = timelocal(&tm_tmp);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
		tt_begin = mktime(&tm_tmp_begin);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
	}

	int shift_hours=0;
	tm tm_tmp_end;
	time_t tt_end;
	memset(&tm_tmp_end, 0, sizeof(struct tm));
	ret = strptime(str_time_end.c_str(), "%Y-%m-%d ", &tm_tmp_end);
	if(!ret)
	{
		stringstream tmp;
		tmp << "Error parsing time string '"<<str_time_end<<"', it has to be YYYY-MM-DD shiftname";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	else
	{
		string shiftname(ret);
		vector<string>::iterator it = find(shiftNames.begin(), shiftNames.end(),shiftname);
		if(it == shiftNames.end())
		{
			stringstream tmp;
			tmp << "Error '"<<shiftname<<"' is not an allowed shift name in (";
			for(vector<string>::iterator itlog=shiftNames.begin(); itlog != shiftNames.end(); itlog++)
			{
				tmp<<*itlog;
				if(itlog != shiftNames.end()-1)
					tmp << ",";
			}
			tmp << ")";

			INFO_STREAM << __func__<< ": " << tmp.str() << endl;
			Tango::Except::throw_exception( \
					(const char*)"PARSING_ERROR", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
		}
		size_t index = it - shiftNames.begin();
		if(index >= shiftNames.size())
		{
			stringstream tmp;
			tmp << "Error not found starting hour for shift '"<<shiftname<<"'";
			INFO_STREAM << __func__<< ": " << tmp.str() << endl;
			Tango::Except::throw_exception( \
					(const char*)"PARSING_ERROR", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
		}
		int begin_shift_hour = shiftStartTimes[index];
		tm_tmp_end.tm_hour = begin_shift_hour;
		tm_tmp_end.tm_isdst = -1;	//user inputs time as localtime already with DST applied
		//time_t tt_end = timelocal(&tm_tmp);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
		tt_end = mktime(&tm_tmp_end);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)

		index = (index + 1) % shiftNames.size();
		int end_shift_hour = shiftStartTimes[index];
		shift_hours = (end_shift_hour + 24 - begin_shift_hour) % 24;

	}
	DEBUG_STREAM << __func__ << ": str_time_begin=" << str_time_begin << " str_time_end=" << str_time_end << " tt_begin=" << (int)tt_begin << " tt_end=" << (int)tt_end << endl;
	if(tt_end < tt_begin)
	{
		stringstream tmp;
		tmp << "Begin time '" << str_time_begin << "' has to precede end time '"<<str_time_end<<"'";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}

	//loop an all shifts exluded the last one
	time_t tt_loop = tt_begin;
	while(tt_loop < tt_end)
	{
		string str_time_ok;
		tm tm_tmpconv;
		gmtime_r(&tt_loop, &tm_tmpconv);	//convert calendar time to UTC tm
		char buf[255];
		strftime(buf, sizeof(buf), "%Y-%m-%d %H", &tm_tmpconv);
		str_time_ok = string(buf);
		ostringstream tmp;
		tmp << KEY_TIME << "=" << str_time_ok << ";" << KEY_ACTIVITY << "=" << str_activity;
		DEBUG_STREAM << __func__ << ": loading '" << tmp.str() << "'" << endl;
		load_line_conf(tmp.str(), false/*time already UTC*/);
		tt_loop += 3600; //increase by one hour
	}

	//loop on the last shift
	int hours_loop=0;
	while(hours_loop < shift_hours)
	{
		string str_time_ok;
		tm tm_tmpconv;
		gmtime_r(&tt_loop, &tm_tmpconv);	//convert calendar time to UTC tm
		char buf[255];
		strftime(buf, sizeof(buf), "%Y-%m-%d %H", &tm_tmpconv);
		str_time_ok = string(buf);
		ostringstream tmp;
		tmp << KEY_TIME << "=" << str_time_ok << ";" << KEY_ACTIVITY << "=" << str_activity;
		DEBUG_STREAM << __func__ << ": loading '" << tmp.str() << "'" << endl;
		load_line_conf(tmp.str(), false/*time already UTC*/);
		tt_loop += 3600; //increase by one hour
		hours_loop++;
	}

	std::ofstream calFile(calendarFile, std::ofstream::out);
	for(map<string,string>::iterator it=calendar.begin(); it!= calendar.end(); it++)
	{
		calFile << KEY_TIME << "=" << it->first << ";" << KEY_ACTIVITY << "=" << it->second << endl;
	}
	calFile.close();
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::load_shift_range_activities
}
//--------------------------------------------------------
/**
 *	Command GetActivity related method
 *	Description: Get the activity for YYYY-MM-DD HH
 *
 *	@param argin YYYY-MM-DD HH
 *	@returns Activity
 */
//--------------------------------------------------------
Tango::DevString Calendar::get_activity(Tango::DevString argin)
{
	Tango::DevString argout;
	DEBUG_STREAM << "Calendar::GetActivity()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Calendar::get_activity) ENABLED START -----*/
	
	//	Add your own code
	string str_time(argin);
	string str_time_ok;
	string activity(UNKNOWN_ACTIVITY);
	tm tm_tmp;
	char *ret;
	memset(&tm_tmp, 0, sizeof(struct tm));
	ret = strptime(str_time.c_str(), "%Y-%m-%d %H", &tm_tmp);
	if(!ret)
	{
		stringstream tmp;
		tmp << "Error parsing time string '"<<str_time<<"', it has to be YYYY-MM-DD HH";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	else
	{
		tm_tmp.tm_isdst = -1;	//user inputs time as localtime already with DST applied
		//time_t tt1 = timelocal(&tm_tmp);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
		time_t tt1 = mktime(&tm_tmp);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
		tm tm_tmpconv1;
		gmtime_r(&tt1, &tm_tmpconv1);	//convert calendar time to UTC tm
		char buf1[255];
		strftime(buf1, sizeof(buf1), "%Y-%m-%d %H", &tm_tmpconv1);
		str_time_ok = string(buf1);
		DEBUG_STREAM << __func__ << ": Converted from LOCAL TIME '" << str_time << "' to UTC '" << str_time_ok << "'" << endl;
		map<string,string>::iterator it = calendar.find(str_time_ok);
		if(it != calendar.end())
			activity =  it->second;
	}
	argout = Tango::string_dup(activity.c_str());

	
	/*----- PROTECTED REGION END -----*/	//	Calendar::get_activity
	return argout;
}
//--------------------------------------------------------
/**
 *	Command GetShiftActivity related method
 *	Description: Get the activity for YYYY-MM-DD shiftname
 *
 *	@param argin YYYY-MM-DD shiftname
 *	@returns Activity
 */
//--------------------------------------------------------
Tango::DevString Calendar::get_shift_activity(Tango::DevString argin)
{
	Tango::DevString argout;
	DEBUG_STREAM << "Calendar::GetShiftActivity()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Calendar::get_shift_activity) ENABLED START -----*/
	
	//	Add your own code
	string str_time(argin);
	string shift_activity(UNKNOWN_ACTIVITY);
	tm tm_tmp;
	char *ret;
	memset(&tm_tmp, 0, sizeof(struct tm));
	ret = strptime(str_time.c_str(), "%Y-%m-%d ", &tm_tmp);
	if(!ret)
	{
		stringstream tmp;
		tmp << "Error parsing time string '"<<str_time<<"', it has to be YYYY-MM-DD shiftname";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	else
	{
		string shiftname(ret);
		vector<string>::iterator it = find(shiftNames.begin(), shiftNames.end(),shiftname);
		if(it == shiftNames.end())
		{
			stringstream tmp;
			tmp << "Error '"<<shiftname<<"' is not an allowed shift name in (";
			for(vector<string>::iterator itlog=shiftNames.begin(); itlog != shiftNames.end(); itlog++)
			{
				tmp<<*itlog;
				if(itlog != shiftNames.end()-1)
					tmp << ",";
			}
			tmp << ")";

			INFO_STREAM << __func__<< ": " << tmp.str() << endl;
			Tango::Except::throw_exception( \
					(const char*)"PARSING_ERROR", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
		}
		if(it - shiftNames.begin() >= shiftNames.size())
		{
			stringstream tmp;
			tmp << "Error not found starting hour for shift '"<<shiftname<<"'";


			INFO_STREAM << __func__<< ": " << tmp.str() << endl;
			Tango::Except::throw_exception( \
					(const char*)"PARSING_ERROR", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
		}
		tm_tmp.tm_hour = shiftStartTimes[it - shiftNames.begin()];
		string shiftname_read;
		get_shift_activity(tm_tmp, shift_activity, shiftname_read);
	}
	argout = Tango::string_dup(shift_activity.c_str());
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::get_shift_activity
	return argout;
}
//--------------------------------------------------------
/**
 *	Command SearchActivity related method
 *	Description: Search for the next activity passed as imput argument
 *
 *	@param argin Activity name
 *	@returns YYYY-MM-DD HH
 */
//--------------------------------------------------------
Tango::DevString Calendar::search_activity(Tango::DevString argin)
{
	Tango::DevString argout;
	DEBUG_STREAM << "Calendar::SearchActivity()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Calendar::search_activity) ENABLED START -----*/
	
	//	Add your own code
	string activity(argin);
	string found_date("");
	char utc_time_string[255];
	strftime(utc_time_string, sizeof(utc_time_string), "%Y-%m-%d %H", &now_utc_tm);
	string now_utc(utc_time_string);
	DEBUG_STREAM << __func__<<": isdst="<<now_utc_tm.tm_isdst<<" utc time: " << utc_time_string<<endl;
	map<string,string>::iterator it = calendar.find(utc_time_string);
	//if not found now, search in the whole calendar
	if(it == calendar.end())
		it = calendar.begin();
	while(it != calendar.end())
	{
		cout << __func__ << ": searching in " << it->first;
		if(it->first > now_utc)
		{
			if(activity == it->second)
			{
				cout << __func__ << ": FOUND " << activity << " in " << it->first;
				//convert from UTC to local

				tm tm_tmp;
				char *ret;
				memset(&tm_tmp, 0, sizeof(struct tm));
				ret = strptime(it->first.c_str(), "%Y-%m-%d %H", &tm_tmp);

				tm_tmp.tm_isdst = -1;	//user inputs time as localtime already with DST applied
				time_t tt1 = timegm(&tm_tmp);	//convert utc tm_tmp to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
				tm tm_tmpconv1;
				localtime_r(&tt1, &tm_tmpconv1);	//convert calendar time to localtime tm
				char buf1[255];
				strftime(buf1, sizeof(buf1), "%Y-%m-%d %H", &tm_tmpconv1);
				found_date = string(buf1);
				DEBUG_STREAM << __func__ << ": Converted from UTC '" << it->first << "' to LOCAL TIME '" << found_date << "'" << endl;
				break;
			}
		}
		it++;
	}
	if(found_date.length() == 0)
	{
		stringstream tmp;
		tmp << "Activity '"<<activity<<"' not found in the future calendar";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"NOT_FOUND", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	argout = Tango::string_dup(found_date.c_str());
	/*----- PROTECTED REGION END -----*/	//	Calendar::search_activity
	return argout;
}
//--------------------------------------------------------
/**
 *	Method      : Calendar::add_dynamic_commands()
 *	Description : Create the dynamic commands if any
 *                for specified device.
 */
//--------------------------------------------------------
void Calendar::add_dynamic_commands()
{
	/*----- PROTECTED REGION ID(Calendar::add_dynamic_commands) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic commands if any
	
	/*----- PROTECTED REGION END -----*/	//	Calendar::add_dynamic_commands
}

/*----- PROTECTED REGION ID(Calendar::namespace_ending) ENABLED START -----*/

//	Additional Methods
void Calendar::load_line_conf(const string &arg, bool convert_local_time)
{
	map<string,string> activity_conf;
	vector<string> v_activity_conf;

	string_explode(arg, ";", v_activity_conf);
	string_vector2map(v_activity_conf,"=",activity_conf);
	string str_time;
	string str_time_ok;
	string str_activity;
	try
	{
		str_time = activity_conf.at(KEY_TIME);
	}
	catch(const std::out_of_range& e)
	{
		stringstream tmp;
		tmp << "Configuration parsing error looking for key '"<<KEY_TIME<<"='";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	try
	{
		str_activity = activity_conf.at(KEY_ACTIVITY);
	}
	catch(const std::out_of_range& e)
	{
		stringstream tmp;
		tmp << "Configuration parsing error looking for key '"<<KEY_ACTIVITY<<"='";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	vector<string>::iterator itact = find(activities.begin(), activities.end(), str_activity);
	if(itact == activities.end())
	{
		stringstream tmp;
		tmp << "Trying to load undefined activity '"<<str_activity<<"'";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}

	tm tm_tmp;
	char *ret;
	memset(&tm_tmp, 0, sizeof(struct tm));
	ret = strptime(str_time.c_str(), "%Y-%m-%d %H", &tm_tmp);
	if(!ret)
	{
		stringstream tmp;
		tmp << "Error parsing time string '"<<str_time<<"', it has to be YYYY-MM-DD HH";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	else
	{
		if(convert_local_time)
		{
			tm_tmp.tm_isdst = -1;	//user inputs time as localtime already with DST applied
			//time_t tt1 = timelocal(&tm_tmp);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
			time_t tt1 = mktime(&tm_tmp);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
			tm tm_tmpconv1;
			gmtime_r(&tt1, &tm_tmpconv1);	//convert calendar time to UTC tm
			char buf1[255];
			strftime(buf1, sizeof(buf1), "%Y-%m-%d %H", &tm_tmpconv1);
			str_time_ok = string(buf1);
			DEBUG_STREAM << __func__ << ": Converted from LOCAL TIME '" << str_time << "' to UTC '" << str_time_ok << "'" << endl;
		}
		else
		{
			char buf1[255];
			strftime(buf1, sizeof(buf1), "%Y-%m-%d %H", &tm_tmp);
			str_time_ok = string(buf1);
			if(str_time_ok != str_time)
				DEBUG_STREAM << __func__ << ": transformed UTC time from '" << str_time << "' to '" << str_time_ok << "'" << endl;
		}
	}
	map<string,string>::iterator itcal = calendar.find(str_time_ok);
	if(itcal == calendar.end())
	{
		DEBUG_STREAM << ": inserting new activity at str_time_ok, activity=" << str_activity << endl;
		calendar.insert(make_pair(str_time_ok, str_activity));
	}
	else
	{
		DEBUG_STREAM << ": updating activity at str_time_ok, from activity=" << itcal->second << " to " << str_activity << endl;
		itcal->second = str_activity;
	}
}

void Calendar::load_shift_conf(const string &arg)
{

	map<string,string> activity_conf;
	vector<string> v_activity_conf;
	string_explode(arg, ";", v_activity_conf);
	string_vector2map(v_activity_conf,"=",activity_conf);
	string str_time_begin;
	string str_time_end;
	string str_activity;
	try
	{
		str_time_begin = activity_conf.at(KEY_TIME);
	}
	catch(const std::out_of_range& e)
	{
		stringstream tmp;
		tmp << "Configuration parsing error looking for key '"<<KEY_TIME<<"='";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	try
	{
		str_activity = activity_conf.at(KEY_ACTIVITY);
	}
	catch(const std::out_of_range& e)
	{
		stringstream tmp;
		tmp << "Configuration parsing error looking for key '"<<KEY_ACTIVITY<<"='";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	vector<string>::iterator itact = find(activities.begin(), activities.end(), str_activity);
	if(itact == activities.end())
	{
		stringstream tmp;
		tmp << "Trying to load undefined activity '"<<str_activity<<"'";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}

	tm tm_tmp_begin;
	time_t tt_begin;

	char *ret;
	memset(&tm_tmp_begin, 0, sizeof(struct tm));
	ret = strptime(str_time_begin.c_str(), "%Y-%m-%d ", &tm_tmp_begin);
	if(!ret)
	{
		stringstream tmp;
		tmp << "Error parsing time string '"<<str_time_begin<<"', it has to be YYYY-MM-DD shiftname";
		INFO_STREAM << __func__<< ": " << tmp.str() << endl;
		Tango::Except::throw_exception( \
				(const char*)"PARSING_ERROR", \
				tmp.str(), \
				(const char*)__func__, Tango::ERR);
	}
	else
	{
		string shiftname(ret);
		vector<string>::iterator it = find(shiftNames.begin(), shiftNames.end(),shiftname);
		if(it == shiftNames.end())
		{
			stringstream tmp;
			tmp << "Error '"<<shiftname<<"' is not an allowed shift name in (";
			for(vector<string>::iterator itlog=shiftNames.begin(); itlog != shiftNames.end(); itlog++)
			{
				tmp<<*itlog;
				if(itlog != shiftNames.end()-1)
					tmp << ",";
			}
			tmp << ")";

			INFO_STREAM << __func__<< ": " << tmp.str() << endl;
			Tango::Except::throw_exception( \
					(const char*)"PARSING_ERROR", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
		}
		size_t index = it - shiftNames.begin();
		if(index >= shiftNames.size())
		{
			stringstream tmp;
			tmp << "Error not found starting hour for shift '"<<shiftname<<"'";
			INFO_STREAM << __func__<< ": " << tmp.str() << endl;
			Tango::Except::throw_exception( \
					(const char*)"PARSING_ERROR", \
					tmp.str(), \
					(const char*)__func__, Tango::ERR);
		}
		int begin_shift_hour = shiftStartTimes[index];
		tm_tmp_begin.tm_hour = begin_shift_hour;
		tm_tmp_begin.tm_isdst = -1;	//user inputs time as localtime already with DST applied
		//time_t tt_begin = timelocal(&tm_tmp);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)
		tt_begin = mktime(&tm_tmp_begin);	//convert local tm_tmp1 to calendar time (seconds since the Epoch, 1970-01-01 00:00:00 +0000, UTC)

		index = (index + 1) % shiftNames.size();
		int end_shift_hour = shiftStartTimes[index];
		int shift_hours = (end_shift_hour + 24 - begin_shift_hour) % 24;

		time_t tt_loop = tt_begin;
		int hours_loop=0;
		while(hours_loop < shift_hours)
		{
			string str_time_ok;
			tm tm_tmpconv;
			gmtime_r(&tt_loop, &tm_tmpconv);	//convert calendar time to UTC tm
			char buf[255];
			strftime(buf, sizeof(buf), "%Y-%m-%d %H", &tm_tmpconv);
			str_time_ok = string(buf);
			ostringstream tmp;
			tmp << KEY_TIME << "=" << str_time_ok << ";" << KEY_ACTIVITY << "=" << str_activity;
			DEBUG_STREAM << __func__ << ": loading '" << tmp.str() << "'" << endl;
			load_line_conf(tmp.str(), false/*time already UTC*/);
			tt_loop += 3600; //increase by one hour
			hours_loop++;
		}
	}
}


void Calendar::get_shift_activity(tm date_shift_local, string &shift_activity, string &str_time_shift)
{
	int hour = date_shift_local.tm_hour;
	size_t index = 0;
	map<string, int> map_shift_activities_count;
	int max_count = 0;
	vector<string> v_string_shift_utc_hours;
	string shiftname;
	if(shiftStartTimes.size() == 0)
		shiftname = string("Shift_00:00");
	size_t index2;
	while(index < shiftStartTimes.size())
	{
		index2 = (index+1) % shiftStartTimes.size();
		//DEBUG_STREAM << " index="<<index<<" index2="<<index2<<" hour="<<hour<<" h1="<<shiftStartTimes[index]<<" h2="<<shiftStartTimes[index2]<<endl;
		if((shiftStartTimes[index] < shiftStartTimes[index2] &&
				(hour >= shiftStartTimes[index] && hour < shiftStartTimes[index2])) ||
			(shiftStartTimes[index] > shiftStartTimes[index2] &&
								(hour >= shiftStartTimes[index] || hour < shiftStartTimes[index2])))
		{
			if(index < shiftNames.size())
			{
				shiftname = shiftNames[index];
			}
			else
			{
				char buffer[100];
				sprintf(buffer,"Shift_%d:00", shiftStartTimes[index]);
				shiftname = string(buffer);
			}
			DEBUG_STREAM << __func__<<": FOUND index="<<index<<" -> shiftname="<<shiftname<<" start hour="<<shiftStartTimes[index] << " end hour="<<shiftStartTimes[index2]<<endl;
			break;
		}
		index++;
	}

	hour = shiftStartTimes[index];
	int diff_start_shift_hours = (date_shift_local.tm_hour + 24 - hour) % 24;
	DEBUG_STREAM << __func__<<" diff_start_shift_hours="<<diff_start_shift_hours<<endl;

	//beginning time of shift in local time
	//convert to utc string time (used as calendar map key)
	tm date_shift_local_begin = date_shift_local;
	date_shift_local_begin.tm_isdst = -1;	//user inputs time as localtime already with DST applied
	//Minutes (0-59)
	date_shift_local_begin.tm_min = 0;
	//Seconds (0-60)
	date_shift_local_begin.tm_sec = 0;
	//subtract difference in hours since start shift
	//time_t date_shift_local_begin_t = timegm(&date_shift_local_begin);
	time_t date_shift_local_begin_t = mktime(&date_shift_local_begin);
	date_shift_local_begin_t = date_shift_local_begin_t - diff_start_shift_hours*3600; //+((hour-shiftStartTimes[index]+24)%24)*3600;//TODO: hour already == shiftStartTimes[index] !!
	tm shift_local_tm;
	localtime_r(&date_shift_local_begin_t, &shift_local_tm);
	char string_local_shift[255];
	strftime(string_local_shift, sizeof(string_local_shift), "%Y-%m-%d", &shift_local_tm);
	str_time_shift = string(string_local_shift) + " " + shiftname;
	DEBUG_STREAM << __func__<<" shift local time="<<str_time_shift << " (hour=" <<shift_local_tm.tm_hour <<")"<< endl;

	time_t date_shift_local_t = date_shift_local_begin_t;
//	date_shift_local_t = date_shift_local_t - diff_start_shift_hours*3600+((hour-shiftStartTimes[index]+24)%24)*3600;

	while((shiftStartTimes[index] < shiftStartTimes[index2] &&
			(hour >= shiftStartTimes[index] && hour < shiftStartTimes[index2])) ||
		(shiftStartTimes[index] > shiftStartTimes[index2] &&
							(hour >= shiftStartTimes[index] || hour < shiftStartTimes[index2])))
	{
#if 0
		//get now utc but without minutes and seconds
		tm now_hour_utc_tm;
		time_t now= time(0);
		gmtime_r(&now, &now_hour_utc_tm); //-> UTC
		/*//Year - 1900
		now_hour_utc_tm.tm_year = now_utc_tm->tm_year;
		//Month (0-11)
		now_hour_utc_tm.tm_mon = now_utc_tm->tm_mon;
		//Day of the month (1-31)
		now_hour_utc_tm.tm_mday = now_utc_tm->tm_mday;
		//Hours (0-23)
		now_hour_utc_tm.tm_hour = now_utc_tm->tm_hour;*/
		//Minutes (0-59)
		now_hour_utc_tm.tm_min = 0;
		//Seconds (0-60)
		now_hour_utc_tm.tm_sec = 0;
#endif
#if 0
		//Minutes (0-59)
		date_shift_local.tm_min = 0;
		//Seconds (0-60)
		date_shift_local.tm_sec = 0;
		//subtract difference in hours since start shift
		time_t date_shift_local_t = timegm(&date_shift_local);
		date_shift_local_t = date_shift_local_t - diff_start_shift_hours*3600+((hour-shiftStartTimes[index]+24)%24)*3600;
#endif


		//beginning time of shift in UTC
		//convert to utc string time (used as calendar map key)
		tm shift_utc_tm;
		gmtime_r(&date_shift_local_t, &shift_utc_tm);
		char string_shift_hour[255];
		strftime(string_shift_hour, sizeof(string_shift_hour), "%Y-%m-%d %H", &shift_utc_tm);
		DEBUG_STREAM << __func__<<" looping hour="<<hour<<" -> " << string_shift_hour << endl;

		//save list of shift utc hours
		v_string_shift_utc_hours.push_back(string_shift_hour);

		//look for the corresponding activity
		map<string,string>::iterator itcal = calendar.find(string_shift_hour);
		if(itcal != calendar.end())
		{
			map<string,int>::iterator itmap = map_shift_activities_count.find(itcal->second);
			if(itmap == map_shift_activities_count.end()) //new activity
			{
				map_shift_activities_count.insert(make_pair(itcal->second, 1));
				if(max_count < 1)
					max_count = 1;
				DEBUG_STREAM << __func__<<" hour="<<hour<<" found new activity=" << itcal->second << " max_count=" << max_count << endl;
			}
			else	//already inserted -> increase counter
			{
				itmap->second = itmap->second + 1;
				if(max_count < itmap->second)
					max_count = itmap->second;
				DEBUG_STREAM << __func__<<" hour="<<hour<<" found existing activity=" << itcal->second << " counter=" << itmap->second << " max_count=" << max_count << endl;
			}
		}
		hour = (hour + 1) % 24;
		date_shift_local_t += 3600;
	}

	//look if more than one activity with the same max counter
	vector<string> activity_modes;
	for(map<string,int>::iterator itmap = map_shift_activities_count.begin(); itmap != map_shift_activities_count.end(); itmap++)
	{
		if(itmap->second == max_count)
		{
			activity_modes.push_back(itmap->first);
			DEBUG_STREAM << __func__<<" found MAX count(" << max_count << ") activity=" << itmap->first << endl;
		}
	}
	if(activity_modes.size() == 1)
	{
		shift_activity =  *(activity_modes.begin());
		DEBUG_STREAM << __func__<<" only one max count activity=" << shift_activity << endl;
	}
	else if(activity_modes.size() > 1)
	{
		DEBUG_STREAM << __func__<<" there are " << activity_modes.size() << " max count activities" << endl;
		//loop from the last hour of the shift
		for (size_t ind = v_string_shift_utc_hours.size(); ind-- > 0; )
		{
			DEBUG_STREAM << __func__<<" - looking for the activity in shift hour=" << v_string_shift_utc_hours[ind] << " max count activities, ind="<<ind << endl;
			//look for the corresponding activity
			map<string,string>::iterator itcal = calendar.find(v_string_shift_utc_hours[ind]);
			if(itcal != calendar.end())
			{
				DEBUG_STREAM << __func__<<" -- found an activity=" << itcal->second << " for shift hour=" << v_string_shift_utc_hours[ind] << endl;
#if 1
				vector<string>::iterator itmodes = find(activity_modes.begin(),activity_modes.end(),itcal->second);
				if(itmodes != activity_modes.end())
				{
					shift_activity = *itmodes;
					DEBUG_STREAM << __func__<<" --- FOUND more recent max count activity =" << shift_activity  << endl;
					ind = 0;//exit also outer loop
					break;
				}
#else

				//loop all max counter activities checking if it is the one of this hour
				for(vector<string>::iterator itmodes=activity_modes.begin(); itmodes != activity_modes.end(); itmodes++)
				{
					DEBUG_STREAM << __func__<<" --- looping max count activities =" << *itmodes  << endl;
					if(*itmodes == itcal->second)
					{
						shift_activity = *itmodes;
						DEBUG_STREAM << __func__<<" --- FOUND more recent max count activity =" << shift_activity  << endl;
						ind = 0;//exit also outer loop
						break;
					}
				}
#endif
			}
		}
	}
	else
	{
		shift_activity = UNKNOWN_ACTIVITY;
		DEBUG_STREAM << __func__<<" --- NO activity during shift -> " << shift_activity  << endl;
	}
}






void Calendar::string_explode(string str, const string &separator, vector<string> &results)
{
	string::size_type found;

	found = str.find_first_of(separator);
	while(found != string::npos)
	{
		if(found > 0)
		{
			results.push_back(str.substr(0,found));
		}
		str = str.substr(found+1);
		found = str.find_first_of(separator);
	}
	if(str.length() > 0)
	{
		results.push_back(str);
	}
}

void Calendar::string_vector2map(const vector<string> &str, const string &separator, map<string,string> &results)
{
	for(vector<string>::const_iterator it=str.begin(); it != str.end(); it++)
	{
		string::size_type found_eq;
		found_eq = it->find_first_of(separator);
		if(found_eq != string::npos && found_eq > 0)
			results.insert(make_pair(it->substr(0,found_eq),it->substr(found_eq+1)));
	}
}

/*----- PROTECTED REGION END -----*/	//	Calendar::namespace_ending
} //	namespace
